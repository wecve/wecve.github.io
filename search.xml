<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018 ISCC Reverse Writeup]]></title>
    <url>%2F2018%2F05%2F27%2F2018ISCC%2F</url>
    <content type="text"><![CDATA[ISCC比赛结束了，这里给各位表哥奉上逆向题的解题思路PS：菜鸡的第一篇博客文，写得不好请见谅！文章最下面有相关题目、脚本下载 一、RSA256(100pt)题目告知了是RSA算法，RSA算法不多说了，百度上一大堆详解下载下来得到三个加密后的文件，和一个公钥(我把题目搞丢了，大概说下思路) 公钥内容如下： 1234-----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhANmelSKWptlg38JQSrpUW5RC1gp7npMK /0UceOxV1VXrAgMBAAE= -----END PUBLIC KEY----- 直接把这个公钥丢到下面网站分析： 在线Rsa 公私钥分解 模数n = D99E952296A6D960DFC2504ABA545B9442D60A7B9E930AFF451C78EC55D555EB 再到下面网站分解质因数：(注意这里只能填十进制数) 在线分解质因数 得到结果： q = 302825536744096741518546212761194311477 p = 325045504186436346209877301320131277983 这里推荐一个脚本 rsatool.py 专门用于RSA算法的脚本加上参数运行脚本，生成私钥private.pem 命令如下： 1python rsatool.py -o private.pem -e 65537 -p 302825536744096741518546212761194311477 -q 325045504186436346209877301320131277983t 最后再用openssl，一波带走这个题 命令如下： 123openssl rsautl -decrypt -in encrypted.message1 -inkey private.pem -out flag1.decopenssl rsautl -decrypt -in encrypted.message2 -inkey private.pem -out flag2.decopenssl rsautl -decrypt -in encrypted.message3 -inkey private.pem -out flag3.dec 二、My math is bad(150pt)程序是64位elf文件，直接丢入IDA分析，可以知道关键函数两个400766和400B16，先进入400766函数中:先是判断输入长度是否为32，就确定了字符串长度为32，我将这些看起来很乱的变量名称重新命名并设置了Hide casts 123456789101112131415161718192021222324252627282930313233343536 if ( strlen(s0) == 32 ) &#123; v3 = s4; v4 = s5; v5 = s6; v6 = s7; result = 0; if ( s1 * *s0 - s3 * s2 == 2652042832920173142LL &amp;&amp; 3LL * s2 + 4LL * s3 - s1 - 2LL * *s0 == 397958918 &amp;&amp; 3 * *s0 * s3 - s2 * s1 == 3345692380376715070LL &amp;&amp; 27LL * s1 + *s0 - 11LL * s3 - s2 == 40179413815LL ) &#123; srand(s2 ^ s1 ^ *s0 ^ s3); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 == 61799700179LL &amp;&amp; v6 + v3 + v5 * v8 - v4 * v7 == 48753725643LL &amp;&amp; v3 * v9 + v4 * v10 - v5 - v6 == 59322698861LL &amp;&amp; v5 * v12 + v3 - v4 - v6 * v11 == 51664230587LL ) &#123; result = 1; &#125; &#125; &#125; else &#123; result = 0LL; &#125; return result;&#125; 这样就可以明显看出字符串被分为了8段int型的值(s0~s7)，我们需要先求出前4段，解方程组(四元一次方程组) z3求解器：z3是由微软公司开发的一个优秀的SMT求解器（也就定理证明器），它能够检查逻辑表达式的可满足性。linux上的安装方法如下： 1pip install z3-solver 安装好后我们就可以在python脚本里调用z3这个库，下面上脚本 123456789101112131415161718from z3 import *import structs=[Int('serial%d' % i) for i in range(4)]solver = Solver()solver.add(s[1]*s[0]-s[3]*s[2] == 2652042832920173142)solver.add(s[2]*3+s[3]*4-s[1]-s[0]*2 == 397958918)solver.add(s[0]*3*s[3]-s[2]*s[1] == 3345692380376715070)solver.add(s[1]*27+s[0]-s[3]*11-s[2] == 40179413815)print(solver.check()) #必须要有这个检查，格式基本固定的answer=solver.model()res = ""for d in s: num = answer.eval(d).as_long() print hex(num) res += struct.pack('&lt;L', num)print repr(res) 通过解此方程组，我们轻易得到了前四段flag 接着随机数种子是前四段异或运算后的值，这里不用去计算它，我们用gdb动态调试(这里犯了个错误，以为只要是随机数种子相同的，那么生成的伪随机数也一样，直接计算出异或后的值，然后生成的伪随机数和程序实际运行产生的伪随机数根本不一样，所以选择动态调试) gdb在0x4008EF下断，一步一步单步走，可以看到随机数种子的值为0x62d793b 最后获得的伪随机数分别为：0x16,0x27,0x2d,0x2d,0x23,0x29,0xd,0x24下一步再解一个方程组，相同道理，直接上脚本了 123456789101112131415161718192021222324252627282930313233from z3 import *import structdata=[Int('serial%d' % i) for i in range(4)]solver = Solver()v3 = data[0]v4 = data[1]v5 = data[2]v6 = data[3]v1 = 0x16v2 = 0x27v7 = 0x2dv8 = 0x2dv9 = 0x23v10 = 0x29v11 = 0xdv12 = 0x24solver.add(v6*v2+v3*v1-v4-v5 == 61799700179)solver.add(v6+v3+v5*v8-v4*v7 == 48753725643)solver.add(v3*v9+v4*v10-v5-v6 == 59322698861)solver.add(v5*v12+v3-v4-v6*v11 == 51664230587)print(solver.check())answer=solver.model()res = ""for d in data: num = answer.eval(d).as_long() print hex(num) res += struct.pack('&lt;L', num)print repr(res) 获得整段字符串后，进入400B16函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243 v35 = *MK_FP(__FS__, 40LL); v3 = 39; v4 = -20; v5 = 19; v6 = 1; v7 = 7; v8 = 6; v9 = 52; v10 = -61; v11 = 72; v12 = -57; v13 = -33; v14 = -79; v15 = -97; v16 = -37; v17 = 25; v18 = 45; v19 = 4; v20 = -15; v21 = -111; v22 = 10; v23 = -94; v24 = -46; v25 = 21; v26 = -43; v27 = -19; v28 = 53; v29 = -112; v30 = -36; v31 = -44; v32 = 60; v33 = 63; v34 = -12; printf("flag&#123;"); for ( i = 0; i &lt; strlen(s0); ++i ) &#123; srand(*&amp;s0[i]); v0 = rand(); putchar(*(&amp;v3 + i) ^ v0 % 255); &#125; puts("&#125;"); return *MK_FP(__FS__, 40LL) ^ v35;&#125; 这里是对输入的字符串进行简单的运算：取每个字节作随机数种子，产生伪随机数，然后再与v3开始的数据进行异或操作 写脚本太麻烦了，直接gdb调试一波，在0x400C44下断，运行后直接一波带走这个题. 三、leftright(150pt)拿到题目后发现有UPX壳，不过也不用脱壳，ESP定律直接到达程序入口点先查找一波字符串，发现疑似flag打乱后长度为29的字符串 1s_imsaplw_e_siishtnt&#123;g_ialt&#125;F 那么如果为了节省时间，自然不必弄清程序流程，先构造一个字符串：小写字母26个+3个数字 1abcdefghijklmnopqrstuvwxyz123 用OD动态调试，找到最终字符串比较的地方下断，输入我们构造的字符串，右边的寄存器窗口直接显示了已经打乱后的另一串字符串为： 1onpqmlrskjtuihvwgfxyedz1cb23a 接下来就根据这最终打乱后的每个字符的位置，一波带走这个题，写出脚本如下： 123456789str0 = "s_imsaplw_e_siishtnt&#123;g_ialt&#125;F" str1 = "abcdefghijklmnopqrstuvwxyz123" str2 = "onpqmlrskjtuihvwgfxyedz1cb23a" flag = ""for i in str1: position=str2.find(i) flag+=str0[position]print flag More info: Writing]]></content>
  </entry>
</search>
