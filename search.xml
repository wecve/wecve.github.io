<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018 ISCC Reverse Writeup]]></title>
    <url>%2F2018%2F05%2F27%2F2018ISCC%2F</url>
    <content type="text"><![CDATA[ISCC比赛结束了，这里给各位表哥奉上逆向题的解题思路PS：菜鸡的第一篇博客文，写得不好请见谅！文章最下面有相关题目、脚本下载 一、RSA256(100pt)题目告知了是RSA算法，RSA算法不多说了，百度上一大堆详解下载下来得到三个加密后的文件，和一个公钥(我把题目搞丢了，大概说下思路) 公钥内容如下： 1234-----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhANmelSKWptlg38JQSrpUW5RC1gp7npMK /0UceOxV1VXrAgMBAAE= -----END PUBLIC KEY----- 直接把这个公钥丢到下面网站分析： 在线Rsa 公私钥分解 模数n = D99E952296A6D960DFC2504ABA545B9442D60A7B9E930AFF451C78EC55D555EB 再到下面网站分解质因数：(注意这里只能填十进制数) 在线分解质因数 得到结果： q = 302825536744096741518546212761194311477 p = 325045504186436346209877301320131277983 这里推荐一个脚本 rsatool.py 专门用于RSA算法的脚本加上参数运行脚本，生成私钥private.pem 命令如下： 1python rsatool.py -o private.pem -e 65537 -p 302825536744096741518546212761194311477 -q 325045504186436346209877301320131277983t 最后再用openssl，一波带走这个题 命令如下： 123openssl rsautl -decrypt -in encrypted.message1 -inkey private.pem -out flag1.decopenssl rsautl -decrypt -in encrypted.message2 -inkey private.pem -out flag2.decopenssl rsautl -decrypt -in encrypted.message3 -inkey private.pem -out flag3.dec 二、My math is bad(150pt)程序是64位elf文件，直接丢入IDA分析，可以知道关键函数两个400766和400B16，先进入400766函数中:先是判断输入长度是否为32，就确定了字符串长度为32，我将这些看起来很乱的变量名称重新命名并设置了Hide casts 123456789101112131415161718192021222324252627282930313233343536 if ( strlen(s0) == 32 ) &#123; v3 = s4; v4 = s5; v5 = s6; v6 = s7; result = 0; if ( s1 * *s0 - s3 * s2 == 2652042832920173142LL &amp;&amp; 3LL * s2 + 4LL * s3 - s1 - 2LL * *s0 == 397958918 &amp;&amp; 3 * *s0 * s3 - s2 * s1 == 3345692380376715070LL &amp;&amp; 27LL * s1 + *s0 - 11LL * s3 - s2 == 40179413815LL ) &#123; srand(s2 ^ s1 ^ *s0 ^ s3); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 == 61799700179LL &amp;&amp; v6 + v3 + v5 * v8 - v4 * v7 == 48753725643LL &amp;&amp; v3 * v9 + v4 * v10 - v5 - v6 == 59322698861LL &amp;&amp; v5 * v12 + v3 - v4 - v6 * v11 == 51664230587LL ) &#123; result = 1; &#125; &#125; &#125; else &#123; result = 0LL; &#125; return result;&#125; 这样就可以明显看出字符串被分为了8段int型的值(s0~s7)，我们需要先求出前4段，解方程组(四元一次方程组) z3求解器：z3是由微软公司开发的一个优秀的SMT求解器（也就定理证明器），它能够检查逻辑表达式的可满足性。linux上的安装方法如下： 1pip install z3-solver 安装好后我们就可以在python脚本里调用z3这个库，下面上脚本 123456789101112131415161718from z3 import *import structs=[Int('serial%d' % i) for i in range(4)]solver = Solver()solver.add(s[1]*s[0]-s[3]*s[2] == 2652042832920173142)solver.add(s[2]*3+s[3]*4-s[1]-s[0]*2 == 397958918)solver.add(s[0]*3*s[3]-s[2]*s[1] == 3345692380376715070)solver.add(s[1]*27+s[0]-s[3]*11-s[2] == 40179413815)print(solver.check()) #必须要有这个检查，格式基本固定的answer=solver.model()res = ""for d in s: num = answer.eval(d).as_long() print hex(num) res += struct.pack('&lt;L', num)print repr(res) 通过解此方程组，我们轻易得到了前四段flag 接着随机数种子是前四段异或运算后的值，这里不用去计算它，我们用gdb动态调试(这里犯了个错误，以为只要是随机数种子相同的，那么生成的伪随机数也一样，直接计算出异或后的值，然后生成的伪随机数和程序实际运行产生的伪随机数根本不一样，所以选择动态调试) gdb在0x4008EF下断，一步一步单步走，可以看到随机数种子的值为0x62d793b 最后获得的伪随机数分别为：0x16,0x27,0x2d,0x2d,0x23,0x29,0xd,0x24下一步再解一个方程组，相同道理，直接上脚本了 123456789101112131415161718192021222324252627282930313233from z3 import *import structdata=[Int('serial%d' % i) for i in range(4)]solver = Solver()v3 = data[0]v4 = data[1]v5 = data[2]v6 = data[3]v1 = 0x16v2 = 0x27v7 = 0x2dv8 = 0x2dv9 = 0x23v10 = 0x29v11 = 0xdv12 = 0x24solver.add(v6*v2+v3*v1-v4-v5 == 61799700179)solver.add(v6+v3+v5*v8-v4*v7 == 48753725643)solver.add(v3*v9+v4*v10-v5-v6 == 59322698861)solver.add(v5*v12+v3-v4-v6*v11 == 51664230587)print(solver.check())answer=solver.model()res = ""for d in data: num = answer.eval(d).as_long() print hex(num) res += struct.pack('&lt;L', num)print repr(res) 获得整段字符串后，进入400B16函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243 v35 = *MK_FP(__FS__, 40LL); v3 = 39; v4 = -20; v5 = 19; v6 = 1; v7 = 7; v8 = 6; v9 = 52; v10 = -61; v11 = 72; v12 = -57; v13 = -33; v14 = -79; v15 = -97; v16 = -37; v17 = 25; v18 = 45; v19 = 4; v20 = -15; v21 = -111; v22 = 10; v23 = -94; v24 = -46; v25 = 21; v26 = -43; v27 = -19; v28 = 53; v29 = -112; v30 = -36; v31 = -44; v32 = 60; v33 = 63; v34 = -12; printf("flag&#123;"); for ( i = 0; i &lt; strlen(s0); ++i ) &#123; srand(*&amp;s0[i]); v0 = rand(); putchar(*(&amp;v3 + i) ^ v0 % 255); &#125; puts("&#125;"); return *MK_FP(__FS__, 40LL) ^ v35;&#125; 这里是对输入的字符串进行简单的运算：取每个字节作随机数种子，产生伪随机数，然后再与v3开始的数据进行异或操作 写脚本太麻烦了，运行后输入刚刚得到的整段字符串，直接一波带走这个题. 三、leftright(150pt)拿到题目后发现有UPX壳，不过也不用脱壳，ESP定律直接到达程序入口点先查找一波字符串，发现疑似flag打乱后长度为29的字符串 1s_imsaplw_e_siishtnt&#123;g_ialt&#125;F 那么如果为了节省时间，自然不必弄清程序流程，先构造一个字符串：小写字母26个+3个数字 1abcdefghijklmnopqrstuvwxyz123 用OD动态调试，找到最终字符串比较的地方下断，输入我们构造的字符串，右边的寄存器窗口直接显示了已经打乱后的另一串字符串为： 1onpqmlrskjtuihvwgfxyedz1cb23a 接下来就根据这最终打乱后的每个字符的位置，一波带走这个题，写出脚本如下： 123456789str0 = "s_imsaplw_e_siishtnt&#123;g_ialt&#125;F" str1 = "abcdefghijklmnopqrstuvwxyz123" str2 = "onpqmlrskjtuihvwgfxyedz1cb23a" flag = ""for i in str1: position=str2.find(i) flag+=str0[position]print flag 四、obfuscation and encode（250pt）这道题做的时间比较长，主要里面有很多混淆的代码，没找到关键的地方，心态就崩了丢入IDA中分析，两个关键的函数fencode和encode，可以明显看出是我们输入的字符串经过两层加密后与 “lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq” 进行比较，相同即为正确flag. 在fencode函数的代码中，采用了很多while进行混淆，其实关键的地方也就三处 1234561.if ( len != 24 ) //这里判断了字符串总长度为242.sum += *(&amp;str[4 * v11] + v8) * *(&amp;m[4 * v10] + v8) //这里v11&lt;6 v10&lt;4 v8&lt;4输入的str字符串与m字符串相乘后求和，是个4x4矩阵乘法3.v6 = i++; str_out[v6] = sum % 127; //这里输出str0 % 127运算后的字符串 静态分析的话，沿着控制流分析一波整个流程类似于以下C代码： 123456789101112for(v11=0; v11&lt;6; v11++)&#123; for(v10=0; v10&lt;4; v10++) &#123; sum = 0; for(v8=0; v8&lt;4; v8++) &#123; sum += str[4 * v11 + v8] * m[4 * v10 + v8]; &#125; str_out[i++] = sum % 127; &#125;&#125; 嵌套循环运算后输出str_out字符串，在encode中对str_out再次加密，找到算法特征处： 从这里可以看出这是一个的base64的算法，不过编码表被改为了：“FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9/mxzpXBky7+”base64加密后的字符串与”lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq” 比较 那么思路已经很明显了，第一层加密同样用Z3求解器解方程组(爆破也可以，但等的太久太久了)，第二层加密在网上找个脚本改下编码表然后解码 先上base64解密脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from numpy import *import numpy as npimport base64import stringimport chardetimport ctypesbase64_charset = 'FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9/mxzpXBky7+'letters = list(base64_charset)def encode(input_str): # 对每一个字节取ascii数值或unicode数值，然后转换为2进制 str_ascii_list = ['&#123;:0&gt;8&#125;'.format(str(bin(ord(i))).replace('0b', '')) for i in input_str] output_str = '' # 不够3的整数倍 补齐所需要的次数 equal_num = 0 while str_ascii_list: temp_list = str_ascii_list[:3] if len(temp_list) != 3: while len(temp_list) &lt; 3: equal_num += 1 temp_list += ['0'*8] temp_str = ''.join(temp_list) # 三个8字节的二进制 转换为4个6字节的二进制 temp_str_list = [temp_str[x:x+6] for x in [0, 6, 12, 18]] # 二进制转为10进制 temp_str_list = [int(x, 2) for x in temp_str_list] # 判断是否为补齐的字符 做相应的处理 if equal_num: temp_str_list = temp_str_list[0:4-equal_num] output_str += ''.join([letters[x] for x in temp_str_list]) str_ascii_list = str_ascii_list[3:] output_str = output_str + '=' * equal_num #print(output_str) return output_strdef decode(input_str): # 对每一个字节取索引，然后转换为2进制 str_ascii_list = ['&#123;:0&gt;6&#125;'.format(str(bin(letters.index(i))).replace('0b', '')) for i in input_str if i != '='] output_str = '' equal_num = input_str.count('=') while str_ascii_list: temp_list = str_ascii_list[:4] temp_str = ''.join(temp_list) # 补够8位 if len(temp_str) % 8 != 0: temp_str = temp_str[0:-1*equal_num*2] # 4个6字节的二进制 转换 为三个8字节的二进制 temp_str_list = [temp_str[x:x+8] for x in [0, 8, 16]] # 二进制转为10进制 temp_str_list = [int(x, 2) for x in temp_str_list if x] output_str += ''.join([chr(x) for x in temp_str_list]) str_ascii_list = str_ascii_list[4:] #print(output_str) return output_strstr0 = decode("lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq")int = [0]*24for i in range(24): int[i] = ord(str0[i])print int 再附上z3求解脚本,那么也就一波带走了今年ISCC的最后一道逆向题 1234567891011121314151617181920212223242526272829from z3 import*key = [37, 192, 59, 166, 31, 175, 76, 165, 203, 139, 164, 155, 59, 225, 40, 133, 38, 38, 22, 231, 17, 9, 7, 38]m =[2, 2, 4, 4294967291, 1, 1, 3, 4294967293, 4294967295, 4294967294, 4294967293, 4, 4294967295, 0, 4294967294, 2]f1 = lambda x1, x2, x3, x4: (x1 * m[0] + x2 * m[1] + x3 * m[2] + x4 * m[3]) &amp; 0xfff2 = lambda x1, x2, x3, x4: (x1 * m[4] + x2 * m[5] + x3 * m[6] + x4 * m[7]) &amp; 0xfff3 = lambda x1, x2, x3, x4: (x1 * m[8] + x2 * m[9] + x3 * m[10] + x4 * m[11]) &amp; 0xfff4 = lambda x1, x2, x3, x4: (x1 * m[12] + x2 * m[13] + x3 * m[14] + x4 * m[15]) &amp; 0xffs = Solver()flag = [BitVec(str(i), 16) for i in range(24)]for i in xrange(6): s.add(f1(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 0]) s.add(f2(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 1]) s.add(f3(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 2]) s.add(f4(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 3])for i in xrange(24): s.add(flag[i]&gt;=32) s.add(flag[i]&lt;=127)print(s.check())answer=s.model()res = ""for i in range(24): res += chr(answer.eval(flag[i]).as_long())print repr(res) 题目打包下载 密码：d1bm]]></content>
  </entry>
</search>
