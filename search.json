[{"title":"2018 ISCC Reverse Writeup","url":"%2F2018%2F05%2F29%2F2018ISCC%2F","content":"ISCC比赛结束了，这里给各位表哥奉上逆向题的解题思路\nPS：菜鸡的第一篇博客文，写得不好请见谅！文章最下面有相关题目、脚本下载\n\n### 一、RSA256(100pt)\n\n题目告知了是RSA算法，RSA算法不多说了，百度上一大堆详解\n下载下来得到三个加密后的文件，和一个公钥(我把题目搞丢了，大概说下思路)\n\n公钥内容如下：\n\n``` bash\n-----BEGIN PUBLIC KEY-----  \nMDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhANmelSKWptlg38JQSrpUW5RC1gp7npMK  \n/0UceOxV1VXrAgMBAAE=  \n-----END PUBLIC KEY-----  \n```\n\n直接把这个公钥丢到下面网站分析：\n\n[在线Rsa 公私钥分解](http://tool.chacuo.net/cryptrsakeyparse)\n\n![Chf1oD.jpg](https://s1.ax1x.com/2018/05/27/Chf1oD.jpg)\n\n模数n = D99E952296A6D960DFC2504ABA545B9442D60A7B9E930AFF451C78EC55D555EB\n\n再到下面网站分解质因数：(注意这里只能填十进制数)\n\n[在线分解质因数](http://factordb.com/)\n\n得到结果： \n\t\t  q = 302825536744096741518546212761194311477\n\t\t  p = 325045504186436346209877301320131277983\n\n这里推荐一个脚本 rsatool.py 专门用于RSA算法的脚本\n加上参数运行脚本，生成私钥private.pem 命令如下：\n\n``` bash\npython rsatool.py -o private.pem -e 65537 -p 302825536744096741518546212761194311477 -q 325045504186436346209877301320131277983t\n```\n\n最后再用openssl，一波带走这个题 命令如下：\n\n``` bash\nopenssl rsautl -decrypt -in encrypted.message1 -inkey private.pem -out flag1.dec\nopenssl rsautl -decrypt -in encrypted.message2 -inkey private.pem -out flag2.dec\nopenssl rsautl -decrypt -in encrypted.message3 -inkey private.pem -out flag3.dec\n```\n\n### 二、My math is bad(150pt)\n\n程序是64位elf文件，直接丢入IDA分析，可以知道关键函数两个400766和400B16，先进入400766函数中:先是判断输入长度是否为32，就确定了字符串长度为32，我将这些看起来很乱的变量名称重新命名并设置了Hide casts\n\n``` bash\n  if ( strlen(s0) == 32 )\n  {\n    v3 = s4;\n    v4 = s5;\n    v5 = s6;\n    v6 = s7;\n    result = 0;\n    if ( s1 * *s0 - s3 * s2 == 2652042832920173142LL\n      && 3LL * s2 + 4LL * s3 - s1 - 2LL * *s0 == 397958918\n      && 3 * *s0 * s3 - s2 * s1 == 3345692380376715070LL\n      && 27LL * s1 + *s0 - 11LL * s3 - s2 == 40179413815LL )\n    {\n      srand(s2 ^ s1 ^ *s0 ^ s3);\n      v1 = rand() % 50;\n      v2 = rand() % 50;\n      v7 = rand() % 50;\n      v8 = rand() % 50;\n      v9 = rand() % 50;\n      v10 = rand() % 50;\n      v11 = rand() % 50;\n      v12 = rand() % 50;\n      if ( v6 * v2 + v3 * v1 - v4 - v5 == 61799700179LL\n        && v6 + v3 + v5 * v8 - v4 * v7 == 48753725643LL\n        && v3 * v9 + v4 * v10 - v5 - v6 == 59322698861LL\n        && v5 * v12 + v3 - v4 - v6 * v11 == 51664230587LL )\n      {\n        result = 1;\n      }\n    }\n  }\n  else\n  {\n    result = 0LL;\n  }\n  return result;\n}\n```\n\n这样就可以明显看出字符串被分为了8段int型的值(s0~s7)，我们需要先求出前4段，解方程组(四元一次方程组)\n\nz3求解器：z3是由微软公司开发的一个优秀的SMT求解器（也就定理证明器），它能够检查逻辑表达式的可满足性。linux上的安装方法如下：\n\n``` bash\npip install z3-solver\n```\n\n安装好后我们就可以在python脚本里调用z3这个库，下面上脚本\n\n``` bash\nfrom z3 import *\nimport struct\ns=[Int('serial%d' % i) for i in range(4)]\nsolver = Solver()\n\nsolver.add(s[1]*s[0]-s[3]*s[2] == 2652042832920173142)\nsolver.add(s[2]*3+s[3]*4-s[1]-s[0]*2 == 397958918)\nsolver.add(s[0]*3*s[3]-s[2]*s[1] == 3345692380376715070)\nsolver.add(s[1]*27+s[0]-s[3]*11-s[2] == 40179413815)\n\nprint(solver.check())  #必须要有这个检查，格式基本固定的\nanswer=solver.model()\nres = \"\"\nfor d in s:\n\tnum = answer.eval(d).as_long()\n        print hex(num)\n\tres += struct.pack('<L', num)\nprint repr(res)\n```\n\n通过解此方程组，我们轻易得到了前四段flag\n\n接着随机数种子是前四段异或运算后的值，这里不用去计算它，我们用gdb动态调试\n(这里犯了个错误，以为只要是随机数种子相同的，那么生成的伪随机数也一样，直接计算出异或后的值，然后生成的伪随机数和程序实际运行产生的伪随机数根本不一样，所以选择动态调试)\n\ngdb在0x4008EF下断，一步一步单步走，可以看到随机数种子的值为0x62d793b\n\n![ChvB7Q.png](https://s1.ax1x.com/2018/05/27/ChvB7Q.png)\n\n最后获得的伪随机数分别为：0x16,0x27,0x2d,0x2d,0x23,0x29,0xd,0x24\n下一步再解一个方程组，相同道理，直接上脚本了\n\n``` bash\nfrom z3 import *\nimport struct\n\ndata=[Int('serial%d' % i) for i in range(4)]\nsolver = Solver()\n\nv3 = data[0]\nv4 = data[1]\nv5 = data[2]\nv6 = data[3]\n\nv1 = 0x16\nv2 = 0x27\nv7 = 0x2d\nv8 = 0x2d\nv9 = 0x23\nv10 = 0x29\nv11 = 0xd\nv12 = 0x24\n\nsolver.add(v6*v2+v3*v1-v4-v5 == 61799700179)\nsolver.add(v6+v3+v5*v8-v4*v7 == 48753725643)\nsolver.add(v3*v9+v4*v10-v5-v6 == 59322698861)\nsolver.add(v5*v12+v3-v4-v6*v11 == 51664230587)\n\nprint(solver.check())\nanswer=solver.model()\nres = \"\"\nfor d in data:\n\tnum = answer.eval(d).as_long()\n        print hex(num)\n\tres += struct.pack('<L', num)\nprint repr(res)\n\n```\n\n获得整段字符串后，进入400B16函数中\n\n``` bash\n  v35 = *MK_FP(__FS__, 40LL);\n  v3 = 39;\n  v4 = -20;\n  v5 = 19;\n  v6 = 1;\n  v7 = 7;\n  v8 = 6;\n  v9 = 52;\n  v10 = -61;\n  v11 = 72;\n  v12 = -57;\n  v13 = -33;\n  v14 = -79;\n  v15 = -97;\n  v16 = -37;\n  v17 = 25;\n  v18 = 45;\n  v19 = 4;\n  v20 = -15;\n  v21 = -111;\n  v22 = 10;\n  v23 = -94;\n  v24 = -46;\n  v25 = 21;\n  v26 = -43;\n  v27 = -19;\n  v28 = 53;\n  v29 = -112;\n  v30 = -36;\n  v31 = -44;\n  v32 = 60;\n  v33 = 63;\n  v34 = -12;\n  printf(\"flag{\");\n  for ( i = 0; i < strlen(s0); ++i )\n  {\n    srand(*&s0[i]);\n    v0 = rand();\n    putchar(*(&v3 + i) ^ v0 % 255);\n  }\n  puts(\"}\");\n  return *MK_FP(__FS__, 40LL) ^ v35;\n}\n```\n\n这里是对输入的字符串进行简单的运算：\n取每个字节作随机数种子，产生伪随机数，然后再与v3开始的数据进行异或操作\n\n写脚本太麻烦了，运行后输入刚刚得到的整段字符串，直接一波带走这个题.\n\n[![C4DeeJ.png](https://s1.ax1x.com/2018/05/28/C4DeeJ.png)](https://imgchr.com/i/C4DeeJ)\n\n\n### 三、leftright(150pt)\n\n拿到题目后发现有UPX壳，不过也不用脱壳，ESP定律直接到达程序入口点\n先查找一波字符串，发现疑似flag打乱后长度为29的字符串\n\n![ChxrDO.png](https://s1.ax1x.com/2018/05/28/ChxrDO.png)\n\n``` bash\ns_imsaplw_e_siishtnt{g_ialt}F\n```\n那么如果为了节省时间，自然不必弄清程序流程，先构造一个字符串：小写字母26个+3个数字\n\n``` bash\nabcdefghijklmnopqrstuvwxyz123\n```\n用OD动态调试，找到最终字符串比较的地方下断，输入我们构造的字符串，右边的寄存器窗口直接显示了已经打乱后的另一串字符串为：\n\n![ChxsbD.png](https://s1.ax1x.com/2018/05/28/ChxsbD.png)\n\n``` bash\nonpqmlrskjtuihvwgfxyedz1cb23a\n```\n\n接下来就根据这最终打乱后的每个字符的位置，一波带走这个题，写出脚本如下：\n\n``` bash\nstr0 = \"s_imsaplw_e_siishtnt{g_ialt}F\"  \nstr1 = \"abcdefghijklmnopqrstuvwxyz123\"  \nstr2 = \"onpqmlrskjtuihvwgfxyedz1cb23a\"  \nflag = \"\"\nfor i in str1:  \n    position=str2.find(i)  \n    flag+=str0[position]\n\nprint flag\n```\n\n### 四、obfuscation and encode（250pt）\n\n这道题做的时间比较长，主要里面有很多混淆的代码，没找到关键的地方，心态就崩了\n丢入IDA中分析，两个关键的函数fencode和encode，可以明显看出是我们输入的字符串经过两层加密后与 \"lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq\" 进行比较，相同即为正确flag.\n\n在fencode函数的代码中，采用了很多while进行混淆，其实关键的地方也就三处\n\n``` bash\n1.if ( len != 24 ) //这里判断了字符串总长度为24\n\n2.sum += *(&str[4 * v11] + v8) * *(&m[4 * v10] + v8) //这里v11<6 v10<4 v8<4\n输入的str字符串与m字符串相乘后求和，是个4x4矩阵乘法\n\n3.v6 = i++; str_out[v6] = sum % 127; //这里输出str0 % 127运算后的字符串\n```\n静态分析的话，沿着控制流分析一波整个流程类似于以下C代码：\n\n``` bash\nfor(v11=0; v11<6; v11++)\n{\n  for(v10=0; v10<4; v10++)\n  {\n    sum = 0;\n    for(v8=0; v8<4; v8++)\n    {\n      sum += str[4 * v11 + v8] * m[4 * v10 + v8];\n    }\n    str_out[i++] = sum % 127;\n  }\n}\n```\n\n嵌套循环运算后输出str_out字符串，在encode中对str_out再次加密，找到算法特征处：\n\n[![C4BfMD.jpg](https://s1.ax1x.com/2018/05/28/C4BfMD.jpg)](https://imgchr.com/i/C4BfMD)\n\n从这里可以看出这是一个的base64的算法，不过编码表被改为了：\n\"FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9/mxzpXBky7+\"\nbase64加密后的字符串与\"lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq\" 比较\n\n那么思路已经很明显了，第一层加密同样用Z3求解器解方程组(爆破也可以，但等的太久太久了)，第二层加密在网上找个脚本改下编码表然后解码\n\n先上base64解密脚本：\n\n``` bash\nfrom numpy import *\nimport numpy as np\nimport base64\nimport string\nimport chardet\nimport ctypes\n\nbase64_charset = 'FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9/mxzpXBky7+'\n\nletters = list(base64_charset)\n\ndef encode(input_str):\n    # 对每一个字节取ascii数值或unicode数值，然后转换为2进制\n    str_ascii_list = ['{:0>8}'.format(str(bin(ord(i))).replace('0b', ''))\n                      for i in input_str]\n    output_str = ''\n    # 不够3的整数倍 补齐所需要的次数\n    equal_num = 0\n    while str_ascii_list:\n        temp_list = str_ascii_list[:3]\n        if len(temp_list) != 3:\n            while len(temp_list) < 3:\n                equal_num += 1\n                temp_list += ['0'*8]\n        temp_str = ''.join(temp_list)\n        # 三个8字节的二进制 转换为4个6字节的二进制\n        temp_str_list = [temp_str[x:x+6] for x in [0, 6, 12, 18]]\n        # 二进制转为10进制\n        temp_str_list = [int(x, 2) for x in temp_str_list]\n        # 判断是否为补齐的字符 做相应的处理\n        if equal_num:\n            temp_str_list = temp_str_list[0:4-equal_num]\n        output_str += ''.join([letters[x] for x in temp_str_list])\n        str_ascii_list = str_ascii_list[3:]\n    output_str = output_str + '=' * equal_num\n    #print(output_str)\n    return output_str\n\n\n\ndef decode(input_str):\n    # 对每一个字节取索引，然后转换为2进制\n    str_ascii_list = ['{:0>6}'.format(str(bin(letters.index(i))).replace('0b', ''))\n                      for i in input_str if i != '=']\n    output_str = ''\n    equal_num = input_str.count('=')\n    while str_ascii_list:\n        temp_list = str_ascii_list[:4]\n        temp_str = ''.join(temp_list)\n        # 补够8位\n        if len(temp_str) % 8 != 0:\n            temp_str = temp_str[0:-1*equal_num*2]\n        # 4个6字节的二进制  转换  为三个8字节的二进制 \n        temp_str_list = [temp_str[x:x+8] for x in [0, 8, 16]]\n        # 二进制转为10进制\n        temp_str_list = [int(x, 2) for x in temp_str_list if x]\n        output_str += ''.join([chr(x) for x in temp_str_list])\n        str_ascii_list = str_ascii_list[4:]\n    #print(output_str)\n    return output_str\n\nstr0 = decode(\"lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq\")\nint = [0]*24\nfor i in range(24):\n  int[i] = ord(str0[i])\nprint int\n```\n再附上z3求解脚本,那么也就一波带走了今年ISCC的最后一道逆向题\n\n``` bash\nfrom z3 import*\n\nkey = [37, 192, 59, 166, 31, 175, 76, 165, 203, 139, 164, 155, 59, 225, 40, 133, 38, 38, 22, 231, 17, 9, 7, 38]\nm =[2, 2, 4, 4294967291, 1, 1, 3, 4294967293, 4294967295, 4294967294, 4294967293, 4, 4294967295, 0, 4294967294, 2]\n\nf1 = lambda x1, x2, x3, x4: (x1 * m[0] + x2 * m[1] + x3 * m[2] + x4 * m[3]) & 0xff\nf2 = lambda x1, x2, x3, x4: (x1 * m[4] + x2 * m[5] + x3 * m[6] + x4 * m[7]) & 0xff\nf3 = lambda x1, x2, x3, x4: (x1 * m[8] + x2 * m[9] + x3 * m[10] + x4 * m[11]) & 0xff\nf4 = lambda x1, x2, x3, x4: (x1 * m[12] + x2 * m[13] + x3 * m[14] + x4 * m[15]) & 0xff\n\ns = Solver()\nflag = [BitVec(str(i), 16) for i in  range(24)]\n\nfor i in xrange(6):\n    s.add(f1(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 0])\n    s.add(f2(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 1])\n    s.add(f3(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 2])\n    s.add(f4(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 3])\n\nfor i in xrange(24):\n    s.add(flag[i]>=32)\n    s.add(flag[i]<=127)\n\nprint(s.check())\nanswer=s.model()\nres = \"\"\nfor i in range(24):\n  res += chr(answer.eval(flag[i]).as_long())\nprint repr(res)\n```\n\n[题目打包下载](https://pan.baidu.com/s/1_acOeyZZUsiJlVneeKI9kw)     密码：d1bm"}]